#' Performs the PeCorA analysis described in https://www.ncbi.nlm.nih.gov/pmc/articles/PMC8592057/.
#' Take a look at the linked paper to get an idea of the procedure.
#'
#' Pass an msnset here to preprocess the data. The result is again an msnset. Can perform two normalization
#' steps, also carried out in the PeCorA paper. Use the parameters peptide_standardize and sample_standardize
#' to select which steps should be performed.
#'
#' If it's desired that both normalization steps be skipped (both set to FALSE), then pecora_preprocess does nothing
#' at all to the data, and this step can be safely skipped.
#'
#' @param m msnset object containing a pData AND fData table. fData must have a Protein and Peptide column.
#' @param treatment_string the name of the column in pData containing treatment information. The data can be numerical of categorical.
#' @param sample_standardize logical for whether exprs data should be standardized so that sample wise we have mean zero and variance one.
#' @param peptide_standardize logical for whether exprs data should be normalized so that logratio data is relative to the control group. When using numerical data, this determines whether to zero center each peptide.
#'
#' @return PeCorA results table for the supplied proteins. Saves plots of the significant peptides to the given folder.
#'
#' @export pecora_preprocess
#'
#'
pecora_preprocess <- function(m, treatment_string, control_group = NULL,
                              sample_standardize = TRUE, peptide_standardize = TRUE){

  mat <- exprs(m)

  if (sample_standardize) {
    cat("Standardizing by sample.\n")
    sample_means <- apply(mat, 2, mean, na.rm = T)
    sample_sds <- apply(mat, 2, sd, na.rm = T)
    mat <- sweep(mat, 2, sample_means, FUN = '-')
    mat <- sweep(mat, 2, sample_sds, FUN = '/')
  }

  metadata <- pData(m) %>%
    select(sym(treatment_string))
  metadata$Sample <- rownames(metadata)

  if (typeof(metadata[[1]]) == "character") {
    metadata[[1]] <- as.factor(metadata[[1]])
  }

  if (peptide_standardize & is.factor(metadata[[1]])) {
    cat("Standardizing to control group.\n")
    if (is.null(control_group)) {
      stop("Must define 'control_group' in order to normalize relative to control\n")
    }

    samples_control <- metadata %>%
      filter(!!sym(treatment_string) == control_group) %>%
      rownames()

    if (length(samples_control) == 0){
      stop("No samples in control group. Please check value of 'control_group' and pData\n")
    }

    ## In case samples_control consists of a single sample we need as.matrix() in the apply call.
    peptide_means <- apply(as.matrix(mat[, samples_control]), 1, mean, na.rm = T)
    mat <- sweep(mat, 1, peptide_means, FUN = '-')

  } else if (peptide_standardize) {

    cat("Mean centering each peptide.\n")
    peptide_means <- apply(mat, 1, mean, na.rm = T)
    mat <- sweep(mat, 1, peptide_means, FUN = '-')

  }

  m.processed <- MSnSet(exprs = mat, fData = fData(m), pData = pData(m))
  pecora_design <- paste0("pecora_design_", treatment_string)
  pData(m.processed)[[pecora_design]] <- metadata[[1]]

  return(m.processed)
}



#' Performs the PeCorA analysis described in https://www.ncbi.nlm.nih.gov/pmc/articles/PMC8592057/.
#' Take a look at the linked paper to get an idea of the procedure.
#'
#' Takes an msnset, a list of proteins, and a treatment variable. msnset is assumed to be normalized, for instance it can be the output of
#' pecora_preprocessing, which normalizes as in the original PeCorA paper.
#' The PeCorA function is then used for the analysis. Returns a table containing Peptide, Protein, and significance.
#'
#' @param m msnset object containing a pData AND fData table. fData must have a Protein and Peptide column.
#' @param treatment_string the name of the column in pData containing treatment information. The data can be numerical of categorical.
#' @param proteins character vector indicating which proteins to analyze.
#' @param median_mod logical for whether to use the original PeCorA (median_mod = FALSE), or the median version (median_mod = TRUE). See the help of PeCorA_mod for more details.
#'
#' @return PeCorA results table for the supplied proteins. Saves plots of the significant peptides to the given folder.
#'
#' @importFrom tidyr pivot_longer
#' @importFrom grid grobTree textGrob gpar
#'
#' @export pecora_analysis
#'
#'
pecora_analysis <- function(m, treatment_string, proteins, median_mod = FALSE){

  mat <- exprs(m)
  peptide_mapping <- fData(m)

  if (!("Protein" %in% colnames(peptide_mapping))){
    stop("fData should have 'Protein' and 'Peptide' columns.\n")
  }

  peptide_mapping <- peptide_mapping %>%
    mutate(Protein = as.character(Protein)) %>%
    select(Protein) %>%
    filter(Protein %in% proteins) %>%
    mutate(Peptide = rownames(.))

  feature_names <- rownames(peptide_mapping)

  metadata <- pData(m) %>%
    select(sym(treatment_string))
  metadata$Sample <- rownames(metadata)

  mat <- mat[feature_names, ]

  if (typeof(metadata[[1]]) == "character") {
    metadata[[1]] <- as.factor(metadata[[1]])
  }

  PeCorA_input <- mat %>%
    as.data.frame() %>%
    mutate(Peptide = rownames(.)) %>%
    pivot_longer(cols = -Peptide, names_to = "Sample", values_to = "LogRatio") %>%
    mutate(modpep_z = Peptide,
           ms1adj = LogRatio) %>%
    merge(peptide_mapping, by = "Peptide") %>%
    merge(metadata, by = "Sample") %>%
    dplyr::rename(Condition = sym(treatment_string))

  pval_test_label <- paste0("pvalue_", treatment_string)

  PeCorA_result <- PeCorA_mod(PeCorA_input, median_mod) %>%
    dplyr::rename(Peptide = peptide,
                  Protein = protein) %>%
    group_by(Protein) %>%
    ## Adjust raw pvalues using only pvalues from the same protein (group by protein)
    mutate(adj_pval_protein_wise = p.adjust(pvalue, method = "BH"))

  pval_index <- which(colnames(PeCorA_result) == "pvalue")[[1]]
  colnames(PeCorA_result)[[pval_index]] <- pval_test_label

  return(PeCorA_result)
}


#' Plots a particular peptide using the PeCorA input and output tables.
#'
#' @param m msnset object containing a pData AND fData table. fData must have a Protein and Peptide column.
#' @param pecora_results PeCorA results table from pecora_analysis.
#' @param chosen_protein The protein of interest.
#' @param chosen_peptide The peptide of interest. Should map to the supplied protein.
#'
#' @return Plot of the specified peptide + protein.
#'
#' @import ggplot2
#' @importFrom grid grobTree textGrob gpar
#'
#' @export pecora_plot
#'
#'
pecora_plot <- function(m, pecora_results,
                        chosen_protein, chosen_peptide) {

  index <- which(grepl("pvalue_", colnames(pecora_results)))

  if (length(index) > 1) {
    stop("Found multiple treatment variables in the given results.\n")
  }

  p.value <- pecora_results %>%
    filter(Peptide == chosen_peptide) %>%
    pull(adj_pval_protein_wise) %>% round(12)

  if (length(p.value) == 0){
    message <- paste0(chosen_protein, " + ", chosen_peptide, " not found within the results.\n")
    stop(message)
  }

  treatment_string <- colnames(pecora_results)[[index]] %>%
    sub("pvalue_", "", .)

  features <- fData(m) %>%
    filter(Protein == chosen_protein) %>%
    mutate(Peptide = rownames(.))

  metadata <- pData(m) %>%
    select(sym(treatment_string)) %>%
    mutate(Sample = rownames(.))

  if (typeof(metadata[[1]]) == "character") {
    metadata[[1]] <- as.factor(metadata[[1]])
  }

  plot_df <- exprs(m)[features$Peptide, ] %>%
    as.data.frame() %>%
    mutate(Peptide = rownames(.)) %>%
    pivot_longer(cols = -Peptide, names_to = "Sample", values_to = "ms1adj") %>%
    mutate(modpep_z = Peptide) %>%
    merge(features, by = "Peptide") %>%
    merge(metadata, by = "Sample") %>%
    dplyr::rename(Condition = sym(treatment_string)) %>%
    mutate(peptide_group = case_when(Peptide == chosen_peptide ~ chosen_peptide,
                                     TRUE ~ "All other peptides")) %>%
    mutate(peptide_group = factor(peptide_group,
                                  levels = c("All other peptides", chosen_peptide)))

  ## Boxplot if condition is a factor. Otherwise, scatterplots when using numerical data.
  if (is.factor(plot_df$Condition)) {

    grob <- grobTree(textGrob(paste0("Adj_pval = ", p.value),
                              x = 0.1,  y = 0.97, hjust = 0,
                              gp = gpar(col = "black", fontsize = 11)))

    p <- ggplot(plot_df, aes(x = Condition, y = ms1adj, fill = peptide_group)) +
      geom_boxplot(notch = TRUE, outlier.shape = NA) +
      ggtitle(chosen_peptide) + annotation_custom(grob) +
      xlab(treatment_string) + ylab("Log Intensity") +
      theme(plot.title = element_text(hjust = 0.5))

  } else {

    plot_df <- plot_df %>%
      mutate(alpha = case_when(peptide_group == "All other peptides" ~ 0.005,
                               TRUE ~ 0.25))

    lm_df <- plot_df %>%
      filter(peptide_group == "All other peptides")
    allothers_lm <- lm(lm_df$ms1adj ~ lm_df$Condition)

    lm_df <- plot_df %>%
      filter(peptide_group == chosen_peptide)
    chosen_lm <- lm(lm_df$ms1adj ~ lm_df$Condition)

    grob <- grobTree(textGrob(paste0("Adj_pval = ", p.value),
                              x = 0.1,  y = 0.97, hjust = 0,
                              gp = gpar(col = "black", fontsize = 11)))

    p <- ggplot(plot_df, aes(x = Condition, y = ms1adj, color = peptide_group, alpha = alpha)) + geom_point() +
      ggtitle(chosen_peptide) + annotation_custom(grob) + xlab(treatment_string) +
      ylab("Log Intensity") + guides(alpha = "none") +
      theme(plot.title = element_text(hjust = 0.5)) +
      geom_abline(intercept = allothers_lm$coefficients[[1]],
                  slope = allothers_lm$coefficients[[2]],
                  color = "red", size = 1) +
      geom_abline(intercept = chosen_lm$coefficients[[1]],
                  slope = chosen_lm$coefficients[[2]],
                  color = scales::hue_pal()(2)[[2]], size = 1)
  }

  return(p)
}




